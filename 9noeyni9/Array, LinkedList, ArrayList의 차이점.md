## 1. Array(배열)
 : **같은 타입**의 여러 변수를 하나의 묶음으로 다루는 것

 ### 특징
  - 순차자료 : '논리적인 저장순서'와 '물리적인 저장순서' 일치
  - 중복 저장 허용
  - 정적인 자료구조 
  - 메모리 공간에 미리 데이터 개수 정해놓는 구조 : 배열 선언시 배열 크기를 지정

 ### Array를 사용할 때
  - 많은 양의 데이터 다룰 때 
  - 정적인 크기의 데이터를 다룰 때 사용
  - 미리 알려진 상황을 다룰 때

#### 배열 생성

  ```java
   타입[] 변수이름; //배열 선언(배열을 다루기 위한 참조 변수)
   변수 이름 = new 타입[배열길이]; // 배열 생성 (저장공간 생성)
   ```

   ```java
   타입[] 변수이름 = new 타입[길이]; // 베열의 선언할 때 생성
   ```

#### 배열 길이 변경
 1. 더 큰 배열을 생성
 2. 기존 배열의 내용을 새로운 배열에 복사
<br>
 : 이러한 방법들은 동적인 크기의 데이터를 다룰 때 비효율적


## 2. ArrayList(배열 리스트)
 : 크기를 정해주지 않아도 되는 **동적인 배열**
 
 ### 특징
  - 순차자료 : '논리적인 저장순서'와 '물리적인 저장순서' 일치
  - 중복 저장 허용
  - 동적인 자료 구조

 ### ArrayList를 사용할 때 
  - 배열의 크기를 미리 알지 못 할 때
  - 데이터를 자주 추가 및 삭제할 때
  
 ### ArrayList 객체 생성
 ```java
 //<> : 저장할 객체 유형
 ArrayList<String> list = new ArrayList<>();
 ```

 ### 데이터 삽입
   - 기존 크기를 초과하지 않는 경우 : 마지막 노드에 추가
   - 기존 크기를 초과하는 경우 : 기존의 크기 + 기존의 크기/2 의 배열에 원소 복사

 ### 데이터 삭제
   - 중간에 있는 데이터 삭제시 뒤에 있던 데이터 끌어옴
   : 대량의 원소를 추가 또는 삭제할 경우 그만큼의 복사를 불러오므로 성능 저하를 일으킴
    

## 3. LinkedList 
  : 객체끼리의 주소 포인터를 가리키며 참조해 이어지는 구조

 ### 특징
   1. 노드를 연결 : 객체 생성 -> 객체의 주소 생성 -> 각각의 객체 주소 참조 -> 연결 형태 구성
   2. 위치에 따라 이동시간 발생
   3. 배열과 달리 고정된 크기 개념X

 ### LinkedList 사용할 때
  - 사용 기록이 남는 데이터 저장할 때(확인해야 하는 기록으로 이동시 유리)
  - 목록 중간에 데이터를 자주 삽입 및 삭제해야 할 때

 ### LinkedList객체 생성
 ```java
 // <> : generic타입 지정 가능
 LinkedList<Integer> list = new LinkedList<Integer>
 ```
   
 #### 데이터 삽입
  - 초기값 미리 지정X
  - 데이터 추가될 때 노드 생성 -> 동적으로 추가되는 방식

 #### 데이터 삭제 
  - 노드 위치의 바로 앞 뒤쪽에 있는 노드 참조 변경
  - 양 끝에서 발생하는 삭제
  - 특정 주소를 포인팅하는 곳

*  *  * 

<br>

### Array,ArrayList,LinkedList 차이  
Array는 고정 길이 데이터 구조이고 ArrayList는 가변 길이 Collection 클래스입니다. Array와 ArrayList는 논리적 저장 순서와 물리적 저장 순서가 일치하므로 index를 통해 해당 원소로 접근할 수 있습니다. 반면 LinkedList는 논리적 저장 순서와 물리적 저장 순서가 다르며 각 원소마다  주소값을 갖고 연결되어 있습니다. LinkedList가 ArrayList보다 자료의 삽입 및 삭제가 편하고 자료 이동이 필요하지 않고 사용 후 기억 장소의 재사용이 가능하다는 장점이 있는 반면 저장공간의 낭비, 자료 탐색에 드는 시간이 많다는 단점이 있습니다.
