# Network & Web
### Network TCP/IP
TCP/IP(Transmission Control Protocol/Internet Protocol)는 OSI 7계층을 단순화하여 4계층으로 정의한 것으로 컴퓨터 간에 통신할 수 있도록 만든 프로토콜 중 하나이고, 인터넷을 기반으로 하고 있습니다.

TCP는 데이터의 흐름 관리, 데이터 정확성 확인 등의 역할을 수행하고, IP는 데이터(패킷)를 목적지까지 전송하는 역할을 담당합니다. TCP/IP는 개방형 구조로 특정 운영체제나 하드웨어에 영향을 받지 않고 근거리와 원거리 모두 데이터를 전송할 수 있습니다.

응용 계층과 전송 계층, 인터넷 계층, 물리 계층으로 나누어져 있습니다. 응용계층은 WWW, FTP, Telnet, SMTP와 같은 네트워크 프로그램이고 전송 계층은 각 시스템을 연결하고 TCP 프로토콜을 이용하여 데이터를 전송합니다. 인터넷 계층은 IP 프로토콜을 이용하여 데이터를 정의하고 경로를 배정하며 물리 계층은 실제 네트워크에 접근할 수 있도록 하는 물리적인 부분을 담당합니다.

### Network IP Address
TCP/IP로 연결된 네트워크에서 각각의 컴퓨터를 구분하기 위해 사용하는 주소이고 ‘123.123.123.123’과 같이 4개로 구분되며 10진수를 사용합니다. Class는 A,B,C,D,E로 구성되어 있고 알파벳 순으로 그 규모가 줄어들며 D는 멀티캐스팅을 위해 정의되고 E는 향후 사용을 위해 예약됩니다.

-	IPv4와 IPv6가 있으며 IPv4의 주소 부족 문제를 해결하고자 나온 것이 IPv6이며 알고리즘과 크기, 구성 등의 차이점을 가지고 있습니다.

### Network Commands
리눅스에는 network와 관련된 여러 개의 명령어가 존재합니다. 그중 몇 가지를 밑에 정리하겠습니다.

nmtui는 리눅스에서 네트워크와 관련된 대부분의 작업을 수행하는 명령어로 자동 IP 주소 또는 고정 IP주소 사용 결정과 IP주소, 서브넷 마스크, 게이트웨이 정보 입력, DNS 정보 입력 등이 있고 IP 주소 변경도 가능합니다. 설정 후에는 리부팅해야 변경사항이 반영됩니다.

systemctl <start/stop/restart/status> network는 네트워크의 설정을 변경한 후에, 변경된 내용을 시스템에 적용시키는 명령어입니다.
Ifconfig <장치이름>은 장치의 IP주소 설정 정보를 출력해주고 ping <IP주소 또는 URL>은 해당 컴퓨터가 네트워크 상에서 응답하는지를 테스트하는 간단한 명령어입니다.

### HTTP 프로토콜
HTTP(Hypertext Transfer Protocol)는 인터넷상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜입니다. 애플리케이션 레벨의 프로토콜로 TCP/IP위에서 작동하고 어떤 종류의 데이터든지 전송할 수 있도록 설계돼 있습니다. 이름은 “하이퍼텍스트 기반으로(Hypertext) 데이터를 전송하겠다(Transfer)”로 링크기반으로 데이터에 접속하겠다는 의미를 가집니다.

-	Connectionless & Stateless 
HTTP는 Connectionless 방식으로 작동하는데 서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버립니다. 기본적으로는 자원 하나에 대해서 하나의 연결을 만들고 이런 작동방식은 각각 아래의 장점과 단점을 가집니다.

**장점**은 불특정 다수를 대상으로 하는 서비스에 적합한 방식이고 수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리할 수 있다는 것이 있습니다.

**단점**은 연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수가 없고, 이러한 HTTP의 특징을 stateless라고 하는데, Connectionless 로부터 파생되는 특징이라고 할 수 있습니다. 클라이언트의 이전 상태 정보를 알 수 없게 되면, 웹 서비스를 하는데 당장에 문제가 생기고, 클라이언트가 과거에 로그인을 성공하더라도 로그 정보를 유지할 수가 없습니다. 

-	HTTP는 cookie를 이용해서 이 문제를 해결하고 있습니다.

### 정적 웹 페이지 (Static Web Page)
웹 서버에 이미 저장된 파일(HTML 파일, 이미지, JavaScript 파일 등)을 클라이언트에게 전송하는 웹 페이지입니다. 사용자는 서버에 저장된 데이터가 변경되지 않는 한 고정된 웹 페이지를 계속 보게 되어 모든 사용자는 같은 결과의 웹 페이지를 서버에 요청하고 응답 받게 됩니다.

장점으로는 다른 처리 없이 요청에 대한 파일만 전송하기 때문에 빠르고 단순한 문서로 웹 서버를 구축하므로 호스팅 서버에 연결하는 비용이 적습니다.

단점은 저장된 정보만 보여주기 때문에 서비스가 한정적이고 추가, 삭제, 수정 등의 작업이 모두 코드를 직접 건드려야 하기 때문에 관리가 힘듭니다.

### 동적 웹 페이지 (Dynamic Web Page)

서버에 저장된 HTML 파일이 그대로 브라우저에 나오는 것이 아닌, 동적으로 만들어지는 웹 페이지로 요청에 관하여 사용자는 조건에 따라 다른 결과를 받게 됩니다. 사용자는 상황, 시간, 요청 등에 따라 달라지는 웹 페이지를 보게 됩니다.

### [ 동적 웹 페이지의 종류 ]

### 1. CSR (Client Side Rendering)
<p align="center">
<img src="/Week1/Day2_Network&Web/image/net1.jpg" width="50%" height="40%"></img>
</p>
<p align="center">
<img src="/Week1/Day2_Network&Web/image/png2.jpg" width="50%" height="40%"></img>
</p>
CSR은 데이터가 없는 HTML 문서나 Static 파일만을 처음에 받아와 로드하고, 이후에 데이터를 요청하여 받아오는 방식으로 자바스크립트를 사용하여 브라우저에서 페이지를 직접 렌더링을 진행합니다. 모든 로직, 데이터 가져오기, 템플릿 및 라우팅 등은 서버가 아닌 클라이언트 측에서 처리합니다.

클라이언트 사이드 렌더링은 클라이언트인 브라우저가 렌더링을 처리하는 방식입니다. 즉, 서버에서 받은 데이터를 통해 클라이언트인 브라우저가 화면(View)을 그리는 주체가 되는 것이죠.

**장점**

네이티브 앱과 비슷한 빠른 인터렉션을 구현할 수 있습니다.
View 렌더링을 브라우저에게 담당시킴으로서 서버 트래픽을 감소시키고, 사용자에게 더 빠른 인터렉션을 제공해 줍니다. 
새로고침이 발생하지 않아 사용자가 네이티브 앱과 비슷한 경험을 할 수 있습니다.

**단점**

첫 페이지 로딩 속도가 서버 사이드 렌더링에 비해 다소 느립니다.
서버에 첫 요청 시 전체 페이지에 대한 모든 문서 파일을 받다 보니 서버 사이드 렌더링보다 로딩 속도가 느립니다.
검색엔진최적화(SEO)에 대한 추가 보완 작업이 필요합니다.
- 포털사이트 검색엔진 크롤러가 웹사이트에 대한 데이터를 제대로 수집하지 못하는 경우가 발생할 수 있습니다. 구글의 검색엔진의 경우 자바스크립트 엔진이 내장되어 있어 크롤링이 되지만, 네이버, 다음의 경우 검색엔진이 제대로 크롤링하지 못하기 때문에 별도의 보완작업이 필요합니다. (예, sitemap 문서 작성)

### 2. SSR (Server Side Rendering)
 
 <p align="center">
<img src="/Week1/Day2_Network&Web/image/png3.jpg" width="50%" height="40%"></img>
</p>

CSR과 상반되게 서버에서 동적으로 데이터까지 전부 삽입하여 완성된 HTML을 넘겨주고, 서버 렌더링은 브라우저에서 응답을 받기 전에 처리되므로 클라이언트에서 데이터를 가져오거나 템플릿 작성에 대한 추가 왕복이 발생하지 않습니다. 

서버 사이드 렌더링은 클라이언트(브라우저)가 서버에 매번 데이터를 요청하여 서버에서 처리하는 방식입니다. 클라이언트에서 요청이 들어올 때마다 매번 서버에서 새로운 화면(View)을 만들어 제공하는 것이죠. 즉, 서버가 화면(View)을 그리는 주체가 됩니다.

**장점**

첫 페이지 로딩 속도가 클라이언트 사이드 렌더링에 비해 더 빠릅니다.
해당 첫 페이지에 해당하는 문서만 브라우저에게 전달하여 브라우저가 렌더링하기 때문에 초기 로딩 속도가 클라이언트 사이드 렌더링에 비해 더 빠릅니다.
검색엔진최적화(SEO)가 가능합니다.

**단점**

초기 로딩 이후 페이지 이동 시 속도가 다소 느립니다.
페이지 이동 시마다 클라이언트가 서버에게 필요한 데이터를 요청하고 서버가 응답해주는 방식이다 보니 속도가 다소 느립니다.

### 3. SPA (Single Page Application)
웹 애플리케이션에 필요한 모든 정적 리소스를 최초 한 번만 다운로드를 합니다. 이후, 새로운 페이지에 대한 요청이 있을 때마다 페이지 갱신에 필요한 데이터만 전달받고 그 정보를 기준으로 페이지를 갱신합니다. (즉, CSR 방식으로 렌더링합니다.)

* SPA는 초기에 HTML이 비어 있기 때문에 검색 엔진에 적절한 정보를 제공할 수 없습니다. (구글과 같은 검색 엔진은 크롤링 과정에서 자바스크립트 실행 결과 까지 알 수 있다고 합니다)

### HTTP Request
**Request Line:** 

HTTP Method - 요청시 보내는 HTTP 메소드 형태입니다. (GET, POST, PUT, PATCH, DELETE, 기타)

Request Header - 어디로 보내는지에 대한 URL입니다.

HTTP Version - HTTP 버전을 나타냅니다.

**Request Header**: 인코딩 방식으로 종류마다 나타내는 것이 다릅니다.

**Host** - 호스트 URL. User-Agent - 클라이언트 정보. Accept - 서버에서 해당 타입에 데이터를 보내달라고 요청하는 헤더. Authorization - JWT 같은 인증 토큰을 서버로 보낼 때 사용하는 헤더.

**Request Body**: HTTP Method는 GET이 아닌 다른 메소드의 경우 Body가 존재합니다.

개발자 모드로 웹 페이지의 Network를 확인하면 몇 개의 request가 있었는지 그 내용은 무엇인지를 확인할 수 있습니다.

### HTTP Response
**Status Line:** 상태 코드와 프로토콜 버전을 나타냅니다.

**HTTP Version** – 응답 온 메세지의 HTTP 버전 정보. **Status Code** - 응답 코드. **Status text** - 응답 상태.

<p align="center">
<img src="/Week1/Day2_Network&Web/image/png4.jpg" width="50%" height="40%"></img>
</p>
 
**Response Header:** 인코딩 방식과 서버 정보를 나타냅니다.

**Date** – 응답 온 일시. **Content-Type** - 응답 데이터의 타입. **Cache-Control** - 캐시용 헤더. 등등
 
 <p align="center">
<img src="/Week1/Day2_Network&Web/image/png5.jpg" width="50%" height="40%"></img>
</p>

**Response Body**: 요청에 대한 응답 값으로 일반적으로 html 내용입니다.

### 이클립스 스프링 환경 설정 정리
자바와 이클립스, 톰캣을 적절한 버전 확인 후 다운로드 받습니다. 하나의 폴더에서 관리하는 것이 용이하므로 설치 후 관리 폴더를 생산해 이동시킵니다. 이클립스에서 help, market에 들어가 spring을 검색 후 다운 받습니다. eclipse.ini에서 다운로드 받은 javaw.exe의 경로를 vm에서 변경시켜줍니다. Settings.xml을 생성하여 관리 폴더에 넣고 window, preference, maven, user setting에서 경로를 변경해주고 update합니다. 

### 자바 스프링 참고 정리

이클립스에서 WEB-INF 폴더에는 다이나믹한 파일, 노출되면 안되는 파일 등을 넣어서 사용합니다. ex) js파일

**통합 개발 환경**(IDE)이란 프로그래머가 소프트웨어 코드를 효율적으로 개발하도록 돕는 소프트웨어 애플리케이션입니다. 이는 소프트웨어 편집, 빌드, 테스트, 패키징과 같은 기능을 사용하기 쉬운 하나의 애플리케이션에 통합하여 개발자 생산성을 높입니다. 일반적으로 IDE는 소스 코드 편집기, 로컬 빌드 자동화, 디버거로 구성되어 있습니다.

**jsp파일**은 java파일로 변환되어 컴파일되고 return된 내용이 웹 브라우저에 렌더링되는 과정을 밟습니다.

**XML**(Extensible Markup Language)은 데이터를 정의하는 규칙을 제공하는 마크업 언어입니다. XML은 다른 목적의 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어입니다.

**log4j**는 자바 기반 로깅 유틸리티로 디버그용 도구로 주로 사용됩니다. 개발자가 로그문의 출력을 다양한 대상으로 할 수 있도록 도와주는 도구로 애플리케이션에 문제 발생시, 로깅 활성화하면 문제의 위치를 정확히 파악할 수 있다는 장점이 있습니다

**build** 소스코드 파일을 컴퓨터에서 실행할 수 있는 독립 소프트웨어 가공물로 변환하는 과정 또는 그에 대한 결과물입니다. 예를 들어 우리가 작성한 소스코드(java), 프로젝트에서 쓰인 각각의 파일 및 자원 등(.xml, .jpg, .jar, .properties)을 JVM이나 톰캣같은 WAS가 인식할 수 있는 구조로 패키징 하는 과정 및 결과물이라고 할 수 있습니다.

**Maven**은 필요한 라이브러리를 특정문서(pom.xml)에 정의만 해주면 사용할 라이브러리뿐 아니라 해당 라이브러리 작동에 필요한 하위 라이브러리까지 네트워크를 통해서 자동으로 다운받아주는 도구를 말합니다. 중앙 저장소를 통한 자동 의존성 관리하고, 중앙 저장소는 라이브러리를 공유하는 파일 서버이고, 저장소는 아파치재단에서 운영관리하는 저장소를 사용할 수도 있고 별도의 사설 저장소를 사용할 수도 있습니다. 

**pom.xml**은 간단히 말하면 Maven의 빌드 정보를 담고 있는 파일로, POM(Project Object Model)을 설정하는 부분으로 프로젝트 내 빌드 옵션을 설정하는 부분입니다. 다른 프로젝트에도 복사-붙여넣기하면 되기 때문에 범용성이 좋고, 협업할 때 버전을 통일하기에 편리합니다.

**Web.xml**은 WebApplication의 Deployment Descriptor(배포 설명자)로서 XML형식의 파일입니다. 모든 Web application은 반드시 하나의 web.xml파일을 가져야 하고 위치는 WEB-INF폴더 아래에 있습니다. web.xml파일의 설정들은 Web Application 시작 시 메모리에 로딩됩니다.

**Controller**는 스프링 프레임워크는 MVC패턴을 사용하고 있고, 여기서 Controller는 화면(View)과 비즈니스 로직(Model)를 연결시키는 다리 역할을 합니다. 쉽게 말하자면 화면에서 /aaa 로 가줘~ 하고 요청하면 주소를 받아들여 어디로 갈지 분석하고 맞는 길로 연결시켜주는 역할입니다. 그 중 HomeController는 최초에 자동 생성되는 파일입니다.

### Java EE, Tomcat, Spring

<p align="center">
<img src="/Week1/Day2_Network&Web/image/png6.jpg" width="50%" height="40%"></img>
</p>

**Java EE**에서 Web Container를 구현한 것이 톰캣입니다. 따라서 톰캣은 온전한 WAS가 아니며 HTTP 요청을 Servlet을 통해 관리합니다. 

- Java EE를 완전히 구현한 것이 WAS인데, 톰캣은 Java EE 중에서도 Web Container만 구현하고 있기 때문입니다.
 
**Java EE**의 단점을 개선하여 탄생한 것이 스프링입니다. 스프링은 POJO 방식의 프로그래밍을 지향하며 비침투적인 기술을 지향합니다.

**Was의 개념** : DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server. HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진)이다. 웹컨테이너 혹은 서블릿 컨테이너라고도 불립니다. 즉 WAS는 JSP, Servlet 구동 환경을 제공합니다.

**WAS의 역할** : WAS = Web Server + Web Container. Web Server 기능들을 구조적으로 분리하여 처리하고자 하는 목적으로 제시되었습니다. 분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용됩니다. 주로 DB 서버와 같이 수행됩니다.
    - 프로그램 실행 환경과 DB 접속 기능 제공
    - 여러개의 트랜잭션 관리 기능
    - 업무를 처리하는 비즈니스 로직 수행
    
**Web Container**는 웹 클라이언트의 HTTP 요청을 받을 수 있고 servlet의 생명 주기를 관리하며 jsp, filter 등을 지원합니다. Java에서는 HTTP 요청을 servlet을 통해 처리하기 때문에 Servlet Container라고도 부릅니다. EJB Container가 웹 브라우저 클라이언트가 요청한 비즈니스 로직을 수행하려면 Web Container를 거쳐야 합니다.

**POJO(Plain Old Java Object)** 방식 즉, 특정 클래스를 상속하거나 인터페이스를 구현하지 않는 가벼운 객체를 원하게 되었습니다. 이런 수요로 인해 Java EE를 개선하여 탄생한 것이 스프링입니다.

이렇듯 스프링은 POJO 방식의 프로그래밍을 지향하면서 적용한 기술이나 메서드가 구현하는 코드에 직접 반영되지 않는 비침투적인(non-invasive) 기술을 사용합니다. 이 비침투적인 기술을 위한 스프링의 핵심 기능이 바로 IoC/DI(Inversion of Control/Dependency Injection), AOP(Aspect Oriented Programimg), PSA(Portable Service Abstraction)인 것입니다. 

**servlet**이란 자바를 사용하여 웹을 만들기 위해 필요한 기술로 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램입니다.  예를 들어, 어떠한 사용자가 로그인을 하려고 할 때. 사용자는 아이디와 비밀번호를 입력하고, 로그인 버튼을 누릅니다. 그때 서버는 클라이언트의 아이디와 비밀번호를 확인하고, 다음 페이지를 띄워주어야 하는데, 이러한 역할을 수행하는 것이 바로 서블릿(Servlet)입니다. 그래서 서블릿은 자바로 구현된 *CGI라고 흔히 말합니다.

### 협업을 위한 팁
각 언어에서 제공하는 스타일 가이드를 따라서 작성하는 것이 중요합니다. 언어마다 네이밍하는 방법과 어떤 형식으로 표시하는지를 다르게 나타냅니다. 이를 유념하고 협업을 위한 올바른 코드를 작성해야 합니다. 
