# SQL(MySQL) & NoSQL(MongoDB)

### 데이터베이스 정의 및 특징
한 조직의 여러 응용 시스템들이 공유하기 위해 통합하고, 저장한 운영 데이터의 집합으로 데이터의 구조적 집합이며, 일반적으로 컴퓨터 시스템을 이용하여 구축한 데이터의 집합을 의미합니다.

### 데이터베이스 관리 시스템
DBMS는 DB를 관리하기 위한 컴퓨터 시스템으로 전사적인 정보 관리 및 효율적이고 편한 사용을 위한 환경을 제공합니다.
실생활의 다양한 환경에서 사용하며, 주요한 개념으로 transaction이 있습니다.

-	Transaction: 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻합니다.데이터베이스의 상태를 변화시킨다는 것은 간단하게 말해서 질의어(SQL)를 이용하여 데이터베이스를 접근 하는 것을 의미합니다.

### ERD란?
Entity Relationship Diagram으로 개체-관계 모델입니다. 테이블 간의 관계를 설명해주는 다이어그램이라고 볼 수 있으며, 이를 통해 프로젝트에서 사용되는 DB의 구조를 한눈에 파악할 수 있습니다. 즉, API를 효율적으로 뽑아내기 위한 모델 구조도라고 생각하면 됩니다.


대략적인 관계를 몇 가지 정리하겠습니다. **One** 일대일 혹은 일대다 관계입니다. 주로 하나의 외래키가 걸린 관계라도 보면 됩니다. **Many** 다대다 관계입니다. 중계 테이블을 통하여 여러 개의 데이터를 바라보고 있을 때 사용합니다. **One or many** 일대일 혹은 다대다 관계를 가지고 있음을 의미하고 관계를 가지고 있으나, 참조되는 row 값들이 불명확함을 의미합니다.

### MYSQL 특징

오라클에 소속되어 있으며 여러 저장소 엔진이 있고, 트랜잭션을 지원하는 저장소 엔진과 지원하지 않는 저장소 엔진이 있습니다. 대용량 데이터베이스에 사용할 수도 있으며 하나의 테이블에 64개의 인덱스를 생성할 수 있고 하나의 인덱스에 16개까지의 컬럼을 지정할 수 있습니다.

### 관계형 모델
관계형 모델은 table의 형태로 row와 column을 가지고 있습니다. 이를 데이터베이스 형태에 비유하자면 relation은 table, attribute는 column을 tuple은 row라고 할 수 있습니다. 데이터베이스는 relation의 집합이고 relation은 tuple의 집합을 의미합니다. Attribute는 relation을 특징을 나타내는 단일 데이터입니다.


Domain 이란 엔티티의 속성들이 가질 수 있는 값들의 집합으로, 관계형 이론에서 도메인은 실제로는 구현이 어렵기 때문에, 대부분의 DBMS에서 도메인이란 속성에 대응하는 컬럼에 대한 데이터 타입(Data Type)과 길이를 의미합니다. ‘두 속성의 도메인이 같다’ 라는 것은 두 속성의 데이터 타입과 길이가 같다는 것을 의미하고 정의된 도메인명은 일반적인 데이터 타입처럼 사용할 수 있습니다.

### Reverse Engineer
	mySQL에서는 해당 기능을 이용하여 ERD를 생성합니다.

### Index
인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료 구조입니다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾는 것은 오랜 시간이 걸립니다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같습니다.


데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있습니다.


**index가 있어도 못 쓰는 경우**: 데이터베이스 원본이 변경될 시 불가능합니다. Index는 조회하기 전의 데이터베이스를 복사하여 만든 자료구조이기에 변경될 시 해당 내용을 조회하는 것이 무의미하기 때문입니다.


**Index 사용 기준 4가지**:  인덱스는 한 테이블당 보통 3~5개가 적당하나 정규화 정도나 테이블의 목적에 따라서는 개수가 달라질 수도 있습니다. 아래 4가지 기준을 사용하여 기준에 부합하는 컬럼을 인덱스로 설정하는 것이 좋습니다.


**카디널리티 (Cardinality)**
카디널리티가 높으면(↑) 인덱스 설정에 좋은 컬럼이다. (인덱스를 통해 불필요한 데이터의 대부분을 걸러낼 수 있음.) **카디널리티가 높다** = 한 컬럼이 갖고 있는 값의 중복도가 낮음. (= 값들이 대부분 다른 값을 가짐.) **카디널리티가 낮다** = 한 컬럼이 갖고 있는 값의 중복도가 높음. (= 값들이 거의 같은 값을 가짐 )


**선택도 (Selectivity)**
선택도가 낮으면(↓) 인덱스 설정에 좋은 컬럼이다. (일반적으로 5~10%가 적당함.) **선택도가 높다** = 한 컬럼이 갖고 있는 값 하나로 여러 row가 찾아진다. **선택도가 낮다** = 한 컬럼이 갖고 있는 값 하나로 적은 row가 찾아진다.


**조회 활용도**
조회 활용도가 높으면(↑) 인덱스 설정에 좋은 컬럼이다. 해당 컬럼이 실제 작업에서 얼마나 활용되는지에 대한 값으로 WHERE의 대상 컬럼으로 많이 활용되는 지로 판단하면 된다.


**수정 빈도**
수정 빈도가 낮으면 인덱스 설정에 좋은 컬럼이다. 인덱스도 테이블이기 때문에, 인덱스로 지정된 컬럼의 값이 바뀌게 되면 인덱스 테이블도 새롭게 갱신되어야 하기 때문이다.

### Primary Key
릴레이션에서 튜플을 구분하기 위하여 사용하는 기본 키입니다. 하나의 속성 또는 속의 집합(복합키)로 구성될 수 있습니다. 자동으로 index가 생성되며 동일한 pk를 지닌 레코드는 존재할 수 없습니다.

### Foreign Key
다른 릴레이션의 기본키를 참조한 것으로 릴레이션 간의 관계를 나타내기 위해 사용하고 null이 가능하다는 특징이 있습니다. 1:N, 1:1 등의 다양한 관계가 존재합니다.

### MySQL 명령어
**Select** – where 절을 이용하여 원하는 조건을 만족하는 row를 선택할 수 있으며 null과 같은 경우는 is null, is not null로 구분하며 데이터가 존재하는지 확인하는 것은 exists를 이용합니다. 


**Oreder by** – 기본 값은 오름차순으로 asc이고 desc 옵션을 주어 내림차순으로 변경 가능합니다. 컬럼 이름 대신 alias (as로 이름을 변경한 것), expr, 절 상에서의 순서를 기준 삼는 것도 가능합니다.


**문자열, 숫자 함수** – 문자열: 다양한 것이 존재하나 concat과 substr과 같이 기본적인 함수를 많이 사용하는 편입니다. 필요할 때 찾아서 사용하는 것이 좋다고 판단됩니다. 숫자: 수를 다루는 함수로 형변환과 절대값, 버림, 반올림 등의 다양한 사용법이 존재합니다.


**날짜 관련 함수** – sysdate(), now() 등으로 현재 시간을 조회 가능하고 date로 형 변환하거나 날짜 함수끼리의 연산 년, 월, 일의 포맷 변경 등이 가능합니다.


**NULL** – null은 값이 없음을 나타내나 정해지지 않은 값이라는 형태로 인식하는 것이 필요합니다. Null이 포함된 연산 결과는 null이기에 그렇습니다. Ifnull을 이용하여 null인 경우의 대체 값 설정이 대표적입니다.


**연산자 우선순위** – 많은 범위가 있지만 그 중 주요한 것은 and가 or 보다 우선순위가 높다는 것과 산술 -> 비교 -> 논리 순으로 적용된다는 것입니다. 원하는 값을 위해서 연산을 괄호로 감싸는 것이 바람직합니다.


### 집계함수의 일반적 오류 및 유의점
**GROUP BY, WHERE** - WHERE 절을 통해 조건에 맞는 데이터를 조회했지만 테이블에 1차적으로 존재하는 데이터 이외의 정보, 예를 들면 각 팀별로 선수가 몇 명인지, 선수들의 평균 신장과 몸무게가 얼마나 되는지, 또는 각 팀에서 가장 큰 키의 선수가 누구인지 등의 2차 가공 정보도 필요합니다. GROUP BY 절은 SQL 문에서 FROM 절과 WHERE 절 뒤에 오며, 데이터들을 작은 그룹으로 분류하여 소그룹에 대한 항목별로 통계 정보를 얻을 때 추가로 사용됩니다.


**GROUP BY 절과 HAVING 절은 다음과 같은 특성을 가집니다.**
- GROUP BY 절을 통해 소그룹별 기준을 정한 후, SELECT 절에 집계 함수를 사용합니다. 
- 집계 함수의 통계 정보는 NULL 값을 가진 행을 제외하고 수행합니다. 
- GROUP BY 절에서는 SELECT 절과는 달리 ALIAS 명을 사용할 수 없습니다. 
- 집계 함수는 WHERE 절에는 올 수 없습니다. (집계 함수를 사용할 수 있는 GROUP BY 절보다 WHERE 절이 먼저 수행됩니다) 
- HAVING 절은 GROUP BY 절의 기준 항목이나 소그룹의 집계 함수를 이용한 조건을 표시할 수 있습니다. 
- GROUP BY 절에 의한 소그룹별로 만들어진 집계 데이터 중, HAVING 절에서 제한 조건을 두어 조건을 만족하는 내용만 출력합니다. 
- HAVING 절은 일반적으로 GROUP BY 절 뒤에 위치합니다.

- WHERE 절은 FROM 절에 정의된 집합(주로 테이블)의 개별 행에 WHERE 절의 조건절이 먼저 적용되고, WHERE 절의 조건에 맞는 행이 GROUP BY 절의 대상이 된다. 그런 다음 결과 집합의 행에 HAVING 조건절이 적용된다. 결과적으로 HAVING 절의 조건을 만족하는 내용만 출력된다. 즉, HAVING 절은 WHERE 절과 비슷하지만 그룹을 나타내는 결과 집합의 행에 조건이 적용된다는 점에서 차이가 있다.

Case 기본적인 CASE 함수의 특징은 아래와 같습니다. 


1. WHEN과 THEN은 최소 한 쌍이 필요
2. WHEN~ THEN구문은 여러 개가 존재 가능
3. 모든 것에 부합하지 않는 경우에는 NULL값으로 출력. 
4. ELSE는 존재할 수도 있고 안 할 수도 있음.
5. 만약 ELSE가 없는데, 모든 조건에서 참이 나오지 않는다면, NULL을 반환
CASE Function은 크게 2가지가 존재합니다. 칼럼을 기준으로 case문을 사용하는 경우와 단순한 조건으로 사용하는 경우로 

 **1. 단순 조건으로 사용하는 CASE 정의**
 ```
CASE 컬럼명
	WHEN 값 A 	THEN 값
	WHEN 값 B 	THEN 값
	ELSE 값 C(취사선택)
END
```

CASE 문 바로 뒤에 칼럼 이름을 쓰고, 그 칼럼의 값과 어떤 값이 같은지(=)를 비교하는 CASE 함수를 단순 CASE 함수라고 합니다.
단순 CASE에서는 등호 연산밖에 할 수 없어, 본인이 설정한 값과 동일한 값이 존재할 때, 처리하는 방법뿐입니다.


**2. 컬럼을 기준으로 하는 CASE 정의**
```
CASE
	WHEN 조건 A
	THEN 조건 A 가 부합하면 출력하는 값
	WHEN 조건 B 
	THEN 조건 B 가 부합하면 출력하는 값
	ELSE '위의 모든 WHEN 조건에 부합하지 않는 경우 출력하는 값 C'(취사선택)
END
```
단순 CASE와는 다르게, 본인이 원하는 조건을 설정할 수 있고 대부분의 CASE문은 이 CASE문입니다.

### MySQL Join
대표적으로 inner join과 outer join이 존재하며 inner join은 join 조건을 만족하는 튜플만 조회되고 outer join은 조건을 만족하지 않는 튜플도 null과 함께 조회됩니다.

Outer join의 종류는 left outer join, right outer join, full outer join이 있으며 테이블의 어느 쪽을 모두 조회할지 결정합니다. 

Self join은 자기 자신과 join 하는 것으로 기본키와 외래키를 연결하여 매니저를 조회하는 방법으로 사용 가능합니다.

### MySQL 서브 쿼리
서브 쿼리는 쿼리 내부에 포함되어 있는 쿼리를 이야기 합니다. 위치에 따른 분류와 동작 방식에 따른 분류, 리턴 되는 데이터에 따른 분류로 구분하며, 위치에 따른 분류에서 from절은 inline 뷰, where 절은 nested 서브쿼리, select 절은 scalar 서브쿼리를 나타냅니다.

서브쿼리를 포함하고 있는 쿼리를 외부쿼리(outer query)라고 부르며, 서브쿼리는 내부쿼리(inner query)라고도 부릅니다. 서브쿼리는 다음과 같이 괄호() 로 감싸져서 표현 됩니다.
 
#### [ 서브 쿼리 실행 순서 ]
서브쿼리 실행 → 메인(부모) 쿼리 실행

<p align="center">
<img src="/Week1/Day3_SQL&NoSQL/image/s1.jpg" width="50%" height="40%"></img>
</p>

서브쿼리(=자식쿼리, 내부쿼리) - 메인쿼리 컬럼 사용 가능

메인쿼리(=부모쿼리, 외부쿼리) - 서브쿼리 컬럼 사용 불가

- Java 객제지향의 상속과 똑같은 개념으로 상속당한 자식 객체는 부모 객체의 인스턴스를 사용할 수 있고, 부모는 자식객체의 인스턴스를 사용할 수 없습니다.

#### [ 서브 쿼리 장점 ]
서브쿼리는 쿼리를 구조화시키므로, 쿼리의 각 부분을 명확히 구분할 수 있게 해줍니다.

서브쿼리는 복잡한 JOIN이나 UNION과 같은 동작을 수행할 수 있는 또 다른 방법을 제공합니다.

서브쿼리는 복잡한 JOIN이나 UNION 보다 좀 더 읽기 편합니다. (가독성이 좋음)

### MySQL 작성 순서와 실행 순서
작성 순서는 SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT이고 실행 순서는 FROM, WHERE, GROUP BY, HAVING, SELECT, ORDER BY, LIMIT 입니다. 작성 순서와 실행 순서가 다른 것을 인지해야 합니다. 쿼리 문은 사용자의 편의를 위해 글처럼 읽히게 설정한 것으로 보입니다. 개발자는 어떤 조건이나 형식이 있을 때 왜 이렇게 구성했는지를 생각할 줄 알아야 합니다.

### NoSQL이란?
NoSQL이라는 용어는 비관계형 데이터베이스 유형을 가리키며 이 데이터베이스는 관계형 테이블과는 다른 형식으로 데이터를 저장합니다. 그러나 NoSQL 데이터베이스는 언어마다 관습화된 API, 선언적 구조의 쿼리 언어, 쿼리별 언어를 사용하여 질의할 수 있습니다. 이 데이터베이스가 not only SQL 데이터베이스라고 불리는 이유입니다.

### MongoDB란?
Mongo DB는 문서 모델(JSON)입니다. 속성의 이름과 값으로 구성되고 속성의 값은 숫자, 문자열, 날짜와 같이 간단한 데이터 타입이나 배열, 또는 다른 문서가 될 수 있습니다. 미리 정해진 스키마 존재하지 않아 자유롭고 구조가 조정되는 초기단계에 매력적입니다.

### MongoDB shell 기본
**Mongo** – mongodb shell을 실행합니다. **Show dbs** - 시스템의 모든 데이터베이스를 출력합니다. **Use user** – user 콜렉션을 사용하게 되고 존재하지 않으면 생성합니다. **db.user.insert({ json 형태의 데이터 })** – 문서를 생성합니다. **db.users.find()** – 생성된 문서를 조회합니다.


### MongoDB Database, Collection, Document
Mongo db의 database는 collection의 집합을 나타내며 collection은 관계형 데이터의 table을 의미합니다. Collection은 document의 집합으로 document는 관계형 데이터의 tuple과 같습니다.

### MongoDB 함수
CRUD가 대표적이며 C는 create으로 insert(), insertOne() 등이 있으며 R은 retrieve로 find(filter, options)가 대표적이고 U는 update(query, update, options) D는 deleteOne(filter, options)가 있습니다. Mongodb는 _id를 넣을 수 있고 고유한 id로 생성됩니다. 이중으로 넣으면 오류가 발생하니 유의해야합니다. 명령어.limit(n)으로 나오는 양을 자를 수 있고 db.emps.find({키:질의선택자})를 이용한 필터링, sort, 명령어.count() 등을 사용하여 원하는 정보를 조회할 수 있습니다.

### MongoDB 실습환경 설정
Node를 다운로드한 후 mongodb를 npm install 합니다. npm init을 하여 패키지를 생성하고 필요한 부분을 작성하여 실습 파일을 node로 실행시킵니다. 이후 터미널에서 요구하는 부분을 만족시키고 실행하면 됩니다.

