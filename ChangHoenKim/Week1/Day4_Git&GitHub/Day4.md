# Git & GitHub

### Git 버전 관리 시스템
버전 관리 시스템(VCS)는 파일 변경을 기록했다가 특정 시점의 버전 코드를 체크 아웃할 수 있으며 프로젝트를 통째로 이전 상태로 되돌릴 수 있습니다. 버전의 수정 내용 비교 및 수정한 팀원을 찾을 수 있습니다.

### 중앙 집중식 버전 관리
중앙 집중식 버전 관리(CVCS)는 프로젝트에서 팀원들이 소스 코드를 공유하기 위해 개발된 것으로 변경된 파일을 저장 순서로 관리합니다. 파일 관리를 위한 서버가 별도로 존재하며 클라이언트가 중앙 서버에서 파일을 check out하여 사용합니다. 하지만 서버가 다운되거나 하드 디스크 크래쉬와 같은 물리적 문제가 생길 경우 모든 히스토리가 사라질 수 있습니다.

### 분산 버전 관리 시스템
분산 버전 관리 시스템(DVCS)은 클라이언트에 단순히 마지막 버전의 소스를 체크아웃하는 게 아닌 히스토리와 더불어 복제할 수 있습니다. 대표적으로 Git이 존재하며 서버에 문제가 생기더라도 이 복제물로 작업할 수 있고, 리모트 저장소가 존재하여 다양한 그룹과 다양한 방법으로 협업이 가능합니다.

### Git Subversion
SVN은 오픈소스 기반의 소스 버전관리 도구입니다. Commit 단위로 관리하고 트리별, 파일별 접근 제어 리스트를 지원하고 CVS(중앙집중식 버전 관리)를 대체할 목적으로 개발되었습니다.
소스 버전 관리 도구는 시스템 형상 요소를 문서화하고 변경을 소스 버전 관리 절차에 따라 관리하고 효율적으로 처리하기 위한 환경을 의미합니다. 프로젝트 팀은 소스 관리 도구에 check in / check out하며 버전을 관리하고 배포와 백업을 반복하며 프로젝트를 이어갑니다.

-	체크 아웃(Check Out) : 저장소(Repository)에서 파일을 가져옵니다.
-	체크 인(Check In, Commit) : 체크 아웃(Check Out)한 파일의 수정이 끝난 경우 저장소(Repository)에 새로운 버전으로 갱신 하는 일입니다. 이때 이전에 갱신된 것이 있는 경우 충돌(conflict)을 알려 주며 diff 도구를 이용해 수정하고 commit하는 과정을 거치게 됩니다

### 소프트웨어 형성 관리란?
소프트웨어의 변경사항을 체계적으로 추적하고 통제하는 것으로, 형상 관리는 일반적인 단순 버전 관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간을 이야기합니다.

형상관리는 변경사항을 체계적으로 추적, 통제한다는 것으로 이 말은 어떤 문서나 파일이 변경되었을 경우 변경된 내역을 기록하였다가 나중에 이를 찾아보아야 할 경우, 변경 원인과 변경 사항을 확인해야 할 경우에 대한 관리를 말합니다.

### Eclipse svn 사용법 정리
Svn을 다운 받고 사용자를 설정하고 repo를 생성합니다. 이클립스의 마켓 플레이스에서 subverive를 검색하여 다운 받습니다. 만약 에러가 발생할 시 help의 install new software의 체크항목을 모두 해제합니다. 다운로드 후 프로젝트 우 클릭 후 Team, share project로 들어가고 svn을 선택 후 url과 사용자의 정보를 입력합니다. svn으로 넘어가 새로 고침하여 확인합니다. 다른 사용자의 서버를 들어가고 싶다면 svn repo에 새롭게 추가하여 url 정보 및 사용자 정보를 입력하여 생성 후 repo를 우 클릭하고 checkout하면 됩니다. 사용자의 버전, 수정 시간, 수정자의 이름을 알 수 있습니다.

Team의 싱크로나이즈를 이용하면 새로 추가되거나 서버에서의 변경사항을 확인시켜줍니다. Commit과 update 즉, check in과 check out이 가능합니다. 

History를 이용하여 해당 repo의 기록을 확인할 수 있습니다. 

충돌 조건: 서버의 repo를 서로 다른 클라이언트가 같은 파일의 내용을 변경하여 서로 commit한 경우 생성됩니다.

### Git
Git은 분산 버전 관리 시스템으로 여러 사람이 협동 작업하는 환경에서 문서 변경 사항을 관리하는 시스템입니다. 특징으로는 저장소가 로컬에 있어 네트워크가 끊어져도 작업 가능하고 다른 버전 관리 시스템보다 빠르며 원격 저장소를 연결해 협동 작업이 가능합니다. 변경 사항을 관리할 대상을 스테이지로 관리할 수 있습니다.

Git의 개발 원칙으로는 빠른 속도, 단순한 구조, 비선형적인 개발, 완벽한 분산 및 대형 프로젝트에도 유용해야 합니다.
-	Pro Git Book을 읽어볼 것을 추천받았습니다.

### Git 파일 저장 방식
Git은 저장소 파일 시스템 전체를 스냅샷으로 취급하여 커밋된 시점의 저장소 상태가 한의 버전이 됩니다. 파일이 달라지지 않은 경우 성능을 위해 파일을 새로 저장하지 않고, 이전 상태의 파일에 대한 링크만 저장합니다. 커밋하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여깁니다,

### Git 세 가지 상태 및 저장소
Git의 파일은 세가지 상태로 관리합니다. **Modified, Staged, Commited**로 Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것을 의미하고 Staged는 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 Commited는 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미합니다. 

저장소에서의 3가지 파일 상태로는 Working Directory에서 작성한 파일을 git commit하여 stage와 history에 보내고 history의 내용을 checkout하여 stage와 working directory에 반영합니다.

로컬 저장소에서 커밋한 작업 내용을 공개하고 싶을 때 원격 저장소에 업로드(Push)하고 원격 저장소에서 다른 사람이 작업한 파일을 로컬 저장소로 가져올 때 Pull합니다.

### GitHub 개요
Git을 사용하는 소프트웨어 개발의 버전 관리를 위한 인터넷 호스팅 서비스로 분산 버전 관리 기능, 접근 제어, 버그 추적 및 지속적인 통합 기능이 있습니다.

**CI**는 간단히 요약하자면 빌드/테스트 자동화 과정 과정입니다. CI는 개발자를 위한 자동화 프로세스인 지속적인 통합(Continuous Integration)을 의미합니다. CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 리포지토리에 통합되므로 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있습니다.
 
**CD**는 간단히 말하면 배포 자동화 과정입니다. CD는 지속적인 서비스 제공(Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미하며 이 두 용어는 상호 교환적으로 사용됩니다. 두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 합니다.

### GitHub Desktop 사용법 정리
저장소를 선택하고 **Clone** 버튼을 눌러 로컬 저장소에 복제합니다. File->new repo..에서 새로운 저장소를 생성 가능합니다. 저장소에 변경 사항이 생기면 commit을 할 수 있습니다. 

Commit 하기 원하는 파일을 선택하고 제목(필수)과 내용을 입력하고 **commit to [branch]**버튼을 누르면 됩니다. 이후 팝업 창에 **Publish Repository**를 클릭하여 Push하면 원격 저장소로 반영됩니다. 커밋을 내용의 확인은 history 탭에서 가능하며 **undo**를 하면 실행 내용을 취소할 수 있습니다. **fetch origin**을 통해 Pull 할 수 있습니다.

Branch -> new branch에 들어가 **create branch**를 하여 새로운 branch를 생성합니다. 파일의 내용을 생성한 후 commit하고 **publish branch**를 한 후 **pull request**를 요청하고 승인한 후 **merge** 버튼을 클릭하면 변경 사항이 master branch로 **통합**됩니다. **history**로 변경 내용을 확인 가능합니다.

같은 repo를 공유하는 상황에서 한 명이 push를 한 후 pull하지 않고 본인의 내용을 push할 경우 **conflict**가 발생합니다. 이런 경우 충돌 내용을 확인한 후 어떤 부분을 반영할 것인지 선택하여 pull하고 다시 push한 이후 create pull request, merge의 과정을 밟으면 해결됩니다.

### 개발자들이 하지 말아야할 일
바탕화면에 폴더를 생성하고 프로젝트를 시작하는 것인데 유저 이름이 한글로 되어있는 경우에 문제가 생기기 때문입니다.
