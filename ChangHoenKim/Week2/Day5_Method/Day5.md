# 자바 언어 기초 
## Day4 실습 5번

출력 요구 사항
```
1	0	0	
2	6	0	
3	7	9	
4	8	0	
5	0	0	
```

```
//      내 코드

	int num = 1;
	int temp;
	int idx = 0;

	while (true) {
		temp = num;
		for (int i = idx; i < arrInt.length - idx; i++) {
			for (int j = idx; j < idx + 1; j++) {
				arrInt[i][j] = num++;
			}
		}
		idx++;
		if (idx == arrInt[0].length || temp == num)
			break;
	}
```
while문 내부에서 열을 이동시키고 만약 변화가 없다면 종료시키게 작성했습니다.

```
        for (int j=0; j < arrInt[0].length; j++) {
			for (int i=j; i < arrInt.length-j; i++)
				nums[i][j] = num++;
		} 
```		

열을 먼저 증가시키고 행을 증가시켰고 값을 빼는 변수를 추가하여 문제를 해결해야 합니다.

## 자바의 메소드

자바의 메소드는 자주 사용되는 프로그램 코드를 정의하는 단위로 다른 언어의 함수와 거의 동일합니다.

자바에는 **main()**이라는 특수 메소드가 존재합니다. 

자바 프로그램에서 수행의 시작점 역할을 하는 것으로 이 메소드가 없으면 main 함수가 없다는 에러를 발생시킵니다.

void : 빈 값을 return해야 하는 예약어입니다.

public static void main(String[] args) 이 메인 코드에서 String[] args가 존재하지 않을 경우 main 메소드로 인식하지 못합니다.

String[] args는 커멘드 Command Line Argument로 자바 코드를 단독으로 사용하여 파일과 같은 데이터를 입력 받을 때 사용하며 특정 데이터 타입과 상관없이 문자열로 전달되며 크기에 무관하게 받기 위해 배열로 전달됩니다.

### 메소드 생성 방법

1. 기능에 따라 메소드명을 지정합니다.
- 메소드명은 소문자로 시작하나 생성자 메소드는 제외합니다.
- 기능을 예측할 수 있는 이름으로 지정해야 합니다.

2. 매개변수와 리턴값에 대한 사양을 정합니다.
- 메소드는 오버로딩을 지원합니다.
- 오버로딩: 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메소드 오버로딩' 또는 간단히 '오버로딩'이라고 합니다. 다만 매개변수의 사양이 서로 달라야합니다.

- 매개변수(parameter) : 메소드가 호출될 때 데이터를 전달받는 변수
- 아규먼트(argument)  : 메소드를 호출할 때 전달하는 데이터(식)

```
// 메소드 정의
// [] : 생략가능한 요소입니다.

[제어자] return값의타입 메소드명([매개변수 선언]) // 메소드 헤더
{
    
    수행 문장; // 원하는 만큼 작성가능합니다.
    [return 리턴값;] // void일 경우 선택이지만 리턴값이 존재할 경우는 해당 타입으로 리턴값을 줘야합니다.

} // block은 필수로 들어가야 하며 "메소드 코드 블록"이라고 부릅니다.

```
- return 값에 올바르지 않은 타입 혹은 어떤 조건이 만족할 때만 값을 리턴하는 방식으로 하면 에러가 출력됩니다.

### 메소드 사용 방법

메소드의 기능이 필요할 때 호출이라는 방법으로 사용합니다.

```
// 메소드 사용
// [] : 생략가능한 요소입니다.

메소드명([아규먼트]);         // 파라미터가 존재해야 아규먼트를 넣습니다.
변수 = 메소드명([아규먼트]);  // 리턴값이 존재할 때만 사용이 가능합니다.

```

## 자바의 데이터 형식

기본형(값을 다루는 타입) : byte(1), short(2), char(2), int(4), long(8), float(4), double(8), boolean(1)

참조형(참조값을 저장하여 참조되는 대상을 다루는 타입) : 객체형 (객체를 참조하는 타입이라는 의미)

### Java5 : 가변형

내부적으로는 배열로 인식되어 만약 배열을 받는 동일한 메소드가 존재할 시 에러를 생성합니다.

m3(int... p) --> m3(), m3(1,2,3), m3(10), m3(new int[] {10,20,30})

m4(char ch, int... p)

printf(String s, object... o)

m5(int... p, char ch) ---> 허용(x)
