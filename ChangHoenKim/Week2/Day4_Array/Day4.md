# 자바 언어 기초 
## 배열(array)이란?

### 배열이란?

배열이란 선형 자료구조(Data Structure)중 하나로 동일한 타입의 연관된 데이터를 메모리에 연속적으로 저장하여 하나의 변수에 묶어서 관리하기 위한 자료 구조입니다. 

많은 양의 데이터를 다뤄야하는 경우 사용하며 처리할 데이터의 타입, 처리할 데이터의 갯수를 결정하여 배열의 타입과 크기를 정해야합니다.

자바에서 배열은 시작은 0번부터 진행됩니다.  

### 배열 선언 방법

값을 이용하여 선언(초기화)하는 방식입니다.  

```
{ 배열 데이터 };
// 위와 같은 방법은 배열 변수와 함께 생성할 때만 허용됩니다.

new 타입[]{ 배열 데이터 };
// 이 방식은 어느 상황에서도 사용할 수 있기에 일반적으로 추천하는 방식입니다. 
```

또는

크기로 선언하는 방식입니다. 미리 방이 만들어지는 것으로 한 번 설정된 방의 갯수는 변화가 불가능합니다. 

이렇게 선언된 경우 배열의 빈공간에는 자바에서 기본으로 설정된 초기 설정 값이 들어가있습니다. ex) int의 기본 값은 0입니다. 

만약 더 큰 배열이 필요하다면 더 큰 배열을 생성해서 내부 값을 이동시켜야합니다. 

이러한 문제를 해결하기위해 자바에서는 용도에 따라 Collection API를 이용합니다.


### 배열 변수 선언 방법

타입[] 변수 이름;

각 배열 요소들의 논리적인 주소 값을 생성하여 참조할 수 있게 합니다.

값을 사용할 수 있는 것이 기본형이라 하고 배열은 주소 값을 참조하여 사용하여 참조형이라고 얘기합니다.


### 배열의 사용 방법

값을 이용하여 선언(초기화)하는 방식입니다.  

int[] nums  = new int[10];

서로는 다른 메모리 공간을 차지합니다. new int[10]으로 배열이 생성되고, int[] nums에 해당 배열의 참조값을 가지게 되는 것입니다.

```
타입[] 변수 이름 = { 배열 데이터 };
// 위와 같은 방법은 사용할 수 있는 환경이 한정되어있습니다.

타입[]  변수 이름 = new 타입[]{ 배열 데이터 };
// 이 방식은 어느 상황에서도 사용할 수 있기에 일반적으로 추천하는 방식입니다. 
```

예시)

```
String [] weeks = {"월", "화", "수", "목", "금", "토", "일"};
int [] score = {"20", "22", "30", "40", "50"};

System.out.print(score);
// [I@1e81f4dc 골뱅이 마크 뒤의 값이 참조값이며 대괄호 I는 배열 int형을 의미합니다.
// 2차원인 경우 [[가 앞에 옵니다.

```

또는

크기로 선언하는 방식입니다. 

```
타입[]  변수 이름 = new 타입[배열 크기];
```

예시)

```
String weeks = new String [7];

weeks[0] = "월";
weeks[1] = "화";
weeks[2] = "수";
weeks[3] = "목";
weeks[4] = "금";
weeks[5] = "토";
weeks[6] = "일";
``` 

```
	char a2[] = {'가', '나', '다'};
	System.out.println(a2);
	>	가나다
```
char형 배열만 특별 취급되어 요소를 하나로 묶어 출력합니다.

### 배열의 길이 구하기

```
String [] arrMonth = {"1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"}; 
System.out.println("length = " + arrMonth.length);

arrMonth[i];
// 여기서 i로 특정 위치의 주소를 참조하여 배열의 값을 가져올 수 있으며 독립된 메모리 공간이기에 l,r-value 둘 다에 사용할 수 있습니다.

```
여기서 .length는 배열 객체의 멤버로 배열 생산시 자동으로 생성되는 것입니다.

참조하는 배열 객체의 크기(길이)를 알려줍니다.

## 자바 실행 파일

자바 .class는 자바의 실행파일로 java 파일이 javac라는 컴파일러를 통해 변환됩니다. 

이클립스에서는 bin 파일 내부에 src 폴더의 .java 파일들이 .class로 변환되어 저장됩니다.

이후 java라는 인터프리터 명령을 통해 class 파일을 읽고 실행됩니다.

자바는 독립적인 JVM(Java Virtual Machine)을 통해 운영체제와 무관하게 사용이 가능합니다. 

### 자바소스파일(.java)이 실행되는 과정

#### 1) 우리가 문서를 작성하고 ctrl+s 눌러서 저장을 하는 순간에 자바 컴파일러(javac.exe)에 의해 자연어인 자바 소스파일(.java)이 --> 바이트 코드(Byte Code)로 이루어진 바이트 코드 파일(.class)로 변환됩니다. (아직 컴퓨터가 읽을 수 없는 상태)


#### 2) JVM은 바이트 코드(Byte code)로 이루어진 .class 파일을 Class Loader를 이용해서 로드하고, 링크를 통해 배치하는 작업을 수행하며, 런타임 시에 동적으로 클래스를 로드합니다. Class Loader는 크게 3가지 영역으로 나뉩니다.


- Loading : .class 파일을 읽고 바이트 코드(Byte code)를 OS에서 할당 받은 메모리 영역인 JVM 메모리 영역(RunTime Data Area) 내부의 Method Area(=Class Area)에 저장합니다. 또한 .class파일이 RunTime Data Area에 Load 된 후에는 JVM이 heap 메모리 영역에 .class 파일이 나타내는 유형의 객체를 생성합니다.

- Linking : 검증(verification), 준비(preparation), 해결(resolution) 3가지를 수행합니다.

- 검증(verification) : 유효한 컴파일러에 의해 생성되었는지 확인하여 .class 파일의 정확성을 보장합니다. 만약 검증에 실패한다면 java.lang.VerifyError가 발생합니다.

- 준비(preparation) : Static Field에 메모리를 할당하고, 메모리를 할당한 변수 타입에 따라 default 값으로 초기화합니다.

- 해결(resolution) : 클래스파일에 참조된 클래스들을 로드합니다. 이때 참조객체들은 Symbolic References를 통해 참조하며 Symbolic References는 Constant Pool 에 저장되어있습니다. 클래스들이 RunTime Data Area에 load 되면 Constant Pool 내부의 Symbolic References를--> Direct References로 전환시킵니다. (즉 실제 메모리값으로 주소를 변경한다.)

- Initialization : Static Field의 값들을 정의한 값으로 초기화 합니다.


#### 3) Class Loader에 의해 .class 파일이 JVM 메모리 영역(RunTime Data Area)에 적재가 됩니다. 이때 RunTime Data Area는 세그멘테이션 구조로 5가지 영역으로 구분됩니다.

- Method Area(=Class Area) : 클래스 이름, 부모 클래스 이름, 메서드, 변수등의 클래스 정보들을 저장. (전역변수 포함) JVM에서 하나의 영역만 존재하고 스레드끼리 공유가 가능합니다.

- Heap Area : new 연산자로 생성된 객체, 배열의 정보를 저장. JVM에서 하나의 영역만 존재하고 스레드끼리 공유가 가능하다. Garbage Collector를 통해서 메모리 반환이 가능.

- Stack Area : 스레드에 대해서 JVM은 메서드를 호출시마다 각각의 Stack 프레임을 생성합니다. 메서드 내부의 지역변수, return 값, 매개변수를 Stack 프레임에 임시로 저장하고 스레드가 끝나면 JVM에 의해서 RunTime Stack이 소멸됩니다. (LIFO구조)

- PC Register : 현재 실행되는 부분의 명령과 주소를 저장. 즉 쓰레드가 어떤 부분을 어떤 명령으로 실행할지에 대한것을 기록하는 부분으로서 현재 수행중인 JVM 명령의 주소값이 저장됩니다.

- Native method stack area : Java 외의 다른 언어에서 제공되는 메서드들이 저장되는 공간. JINI(Java Native Interface) 라는 표준 규약을 제공합니다.


#### 4) Execution Engine은 JVM 메모리 영역에 적재된 Byte code로 이루어진 .class 파일을 기계어로 변경하여 명령어(instruction) 단위로 실행하며, 이때 3가지 영역으로 구분됩니다.

- 인터프리터(Interpreter) : Byte code를 1줄씩 해석하고 실행합니다.

- Just In Time Compiler(JIT 컴파일러) : 전체 Byte code를 필요한 만큼 쪼개서 실시간으로 실행가능한 상태로 컴파일합니다.

- Garbage Collector : 참조되지 않은 객체들을 삭제하고 삭제된 객체의 메모리를 반환한다. 또한 Heap 메모리를 재사용합니다.


### 자바 for each문
```
for(int data : nums)  // foreach
	System.out.print(data+ " ");
```
r-value만 사용가능하고 순서대로 한 칸씩만이 출력됩니다.

### 난수 생성 과제 - 짧은 코드
```
		for(int i = 0; i < lottoNumbers.length; i++) {
			lottoNumbers[i] = (int)(Math.random()*45)+1;
			for(int j = 0; j < i; j++) {
				if(lottoNumbers[i] == lottoNumbers[j]) 
					i--;
			}
		}
```
## 2차원 배열

테이블 형식으로 달력이나 구조가 2중인 자료를 표현할때 효율적으로 사용이 가능합니다.
```
	new 타입[행의 크기][열의 크기]
```
위와 같은 형식으로 배열을 선언합니다.

```
	타입 [][] 변수명; 타입 변수명[][]; 타입[] 변수명[];
```
위와 같은 형식으로 변수를 선언합니다.

자바의 2차원 배열 저장 형식은 array of array입니다.

### 1. 바로 가기 구문

Java에서 2차원 어레이을 선언하고 초기화하는 가장 일반적인 방법은 어레이 이니셜라이저와 함께 바로 가기 구문을 사용하는 것입니다.
```
	int[][] arr =
	{
		{1, 2, 3}, // 첫번째 행
		{4, 3, 6}, // 두번째 행
		{7, 8, 9}  // 세번째 행
	};

```
### 2. 신규 오퍼레이터

아래와 같이 new 연산자를 사용하여 2차원 어레이을 선언하고 초기화할 수도 있습니다.
```
	int[][] arr;            // 어레이 선언
	arr = new int[3][4];    // 메모리 할당
 ```
이니셜라이저를 제공하지 않았으므로 int 또는 long 또는 short 또는 byte 어레이의 경우 각 요소에 기본값 0이 할당됩니다. 기본값은 문자열의 경우 null이고 double 또는 float의 경우 기본값은 0.0입니다.

### 3. 선언과 초기화 결합

2차원 어레이의 선언과 초기화를 한 줄에 결합할 수 있습니다.
```
	int[][] arr = new int[3][4];
```
### 4. 2차원 건너뛰기

2차원 어레이의 두 번째 차원은 선택 사항이며 아래와 같이 첫 번째 차원만 지정하여 2차원 어레이을 선언할 수 있습니다.
```
	int[][] arr = new int[3][];
	
	arr[0] = new int[4];
	arr[1] = new int[4];
	arr[2] = new int[4];
```
첫 번째 차원을 지정해야 합니다. 그렇지 않으면 컴파일러에서 컴파일 오류가 발생합니다.

### 5. 가변 어레이

가변 어레이의 요소는 차원과 크기가 다를 수 있습니다.

2차원 어레이는 1차원 어레이의 어레이일 뿐이기에 Java에서는 개별 1차원 어레이의 길이가 다른 2차원 어레이을 생성하는 것이 가능합니다. 

```
	int[][] arr = new int[3][];
	
	arr[0] = new int[1];
	arr[1] = new int[2];
	arr[2] = new int[3];
```
그러면 아래와 같이 2차원 어레이이 생성됩니다.
```
	[0]
	[0, 0]
	[0, 0, 0]
```
### 6. Array Initializer로 열 초기화

아래와 같이 어레이 이니셜라이저를 사용하여 길이가 다른 열을 초기화할 수도 있습니다.
```
	int[][] arr =
	{
		{ 1 },
		{ 1, 2 },
		{ 1, 2, 3 }
	};
```
또는
```
	int[][] arr = new int[3][];
	
	arr[0] = new int[] { 1 };
	arr[1] = new int[] { 1, 2 };
	arr[2] = new int[] { 1, 2, 3 };
```
위 코드의 결과는 다음과 같습니다.
```
	[1]
	[1, 2]
	[1, 2, 3]
```
