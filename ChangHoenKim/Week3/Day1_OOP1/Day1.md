# 자바 언어 기초

## 프로그래밍 언어의 종류

- 순차지향 프로그래밍 언어(Sequential Oriented Programming Language)
  : 프로그램 시작시 코드를 한행씩 내려가면서 수행하는 것을 말합니다. ex) 어셈블리언어

- 절차지향 프로그래밍 언어(Procedural Oriented Programming Language)
  : 절차지향 프로그래밍이란 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다. 대표적인 절차지향 언어에는 C언어가 있습니다. 이는 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리합니다.

- 객체지향 프로그래밍 언어(Object Oriented Programming Language)
  : 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)은 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.
  대표적으로 자바가 존재합니다.

## 객체지향 언어

### [ 객체지향 언어의 역사 ]

- 과학, 군사적 모의실험(simulation)을 위해 컴퓨터를 이용한 가상세계를 구현하려는 노력으로부터 객체지향이론이 시작됐습니다.

- 1960년대 최초의 객체지향언어 Simula탄생

- 1980년대 절차방식의 프로그래밍의 한계를 객체지향방식으로 극복하려고 노력했습니다.
  (C++, Smalltalk과 같은 보다 발전된 객체지향언어가 탄생)

- 1995년 말 Java탄생. 객체지향언어가 프로그래밍 언어의 주류가 됐습니다.

### [ 객체지향 언어의 장점과 특징 ]

- 프로그램을 보다 유연하고 변경이 용이하게 만들 수 있습니다.

- 마치 컴퓨터 부품을 갈아 끼울 때, 해당하는 부품만 쉽게 교체하고 나머지 부품들을 건드리지 않아도 되는 것처럼 소프트웨어를 설계할 때 객체 지향적 원리를 잘 적용해 둔 프로그램은 각각의 부품들이 각자의 독립적인 역할을 가지기 때문에 코드의 변경을 최소화하고 유지보수를 하는 데 유리합니다.

- 코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현할 수 있습니다.

- 객체 지향 프로그래밍의 4가지 특징은 각각 **추상화, 상속, 다형성, 캡슐화**인데, 모두 이러한 객체지향적 설계의 이점들을 가장 잘 살릴 수 있는 방향으로 발전되어 왔습니다.

### 상속의 개념

#### 상속(Inheritance)

현실 세계에서 부모님이 자식들에게 재산을 물려주는 것과 비슷합니다. 다만 차이라고 하면 자식(클래스)이 상속받고 싶은 부모(클래스)를 선택해서 물려받습니다. 이때 상속받는 클래스를 자식 클래스, 하위 클래스 또는 서브 클래스라고 부르며, 상속을 해주는 클래스를 부모 클래스, 상위 클래스 또는 슈퍼 클래스라고 합니다.

#### 상속의 대상

자식 클래스가 부모 클래스로부터 상속을 받게 되면 부모 클래스의 필드와 메소드를 물려받게 됩니다. 단, 접근제어자가 private을 갖는 필드나 메소드는 상속이 불가하고, 패키지가 다를 경우 접근제어자가 default인 경우도 상속이 불가합니다.

## 객체

### 객체의 구성요소 – 속성과 기능

```
class Tv{
    String color;
    boolean power;
    int channell;

    void power() {power = !power; }
    void channelUp {channel++;}
    void channelDown {channel--;}
}
```

객체는 속성과 기능으로 이루어져 있습니다.

- 객체는 속성과 기능의 집합이며, 속성과 기능을 객체의 멤버(member, 구성요소)라고 합니다.

속성은 변수로, 기능은 메소드로 정의합니다.

- 클래스를 정의할 때 객체의 속성은 변수로, 기능은 메소드로 정의합니다.

### 인스턴스의 생성과 사용

#### 인스턴스의 생성방법

```
클래스명 참조변수명;  // 객체를 다루기 위한 참조변수 선언

참조변수명 = new 클래스명(); // 객체생성 후, 생성된 객체의
   주소를 참조변수에 저장

Tv t;
t = new Tv();

Tv t = new Tv();
```

다음에 new연산자를 이용해서 객체를 생성하고 new연산자가 반환하는 생성된 객체의 주소가 참조변수에 저장되게 하면 됩니다.

new연산자는 인스턴스를 생성할 클래스를 읽어서 인스턴스 생성에 필요한 메모리를 계산한 다음에 메모리의 빈 공간을 찾아
객체를 생성합니다. 그리고 생성된 객체의 메모리 주소를 반환합니다.

그러면, 이제 생성된 인스턴스를 참조변수로 다룰 수 있게 됩니다.

만일 앞서 정의한 Tv클래스의 인스턴스를 생성하려면 먼저 Tv타입의 참조변수 t를 선언하면 참조변수 t가 생깁니다.

그 다음에 new연산자를 이용해서 Tv인스턴스를 생성합니다. new연산자는 Tv클래스에 정의된 내용대로 메모리에 객체를 생성합니다. 각 변수에는 변수의 타입에 따른 기본값으로 자동초기화가 됩니다.

그리고는 생성된 Tv인스턴스의 주소를 반환하고 대입연산자에 의해서 반환된 Tv인스턴스의 주소가 참조변수 t에 저장됩니다.

참조변수는 인스턴스를 다룰 수 있는 유일한 방법이기 때문에 참조변수가 없으면 인스턴스를 사용할 수 없습니다.

사용할 수 없는 인스턴스는 JVM의 가비지컬렉터에 의해서 적절한 시기에
자동적으로 메모리에서 제거됩니다.

그래서 개발자는 사용되지 않는 인스턴스를 제거하는데 신경쓰지 않아도 되기 때문에 메모리관리의 부담이 없다는 것이 Java의 큰 장점입니다.

### 인스턴스의 생성과 사용

```
Tv t;
t = new Tv();
t.channel = 7;
t.channelDown();

System,out.println(t.channel);
```
참조변수를 통해서 인스턴스를 다루는 방법을 알아보겠습니다.

먼저 Tv인스턴스를 다루기 위한 참조변수 t를 선언하고 Tv인스턴스를 생성합니다. 이후 7을 참조변수 t가 가리키는 객체의 channel에 저장합니다.
그 결과 Tv인스턴스의 속성 channel의 값이 0에서 7로 바뀝니다.

인스턴스의 속성에 접근할 때는 이처럼 ‘참조변수.속성’과 같은 형식으로 하면 됩니다. 인스턴스의 기능 즉 메소드를 호출할 때도 ‘참조변수.메소드’와 같이 합니다.

이후 참조변수 t가 가리키는 인스턴스의 channelDown메소드를 호출하면 channelDown에 정의된 코드가 수행되어 속성 channel의 값을 1감소 시킵니다.
결과적으로 channel의 값은 7에서 1이 감소된 6이 됩니다.

```
Tv t1 = new Tv();
Tv t2 = new Tv();

t2 = t1;
```

해당 코드의 결과는 t2를 가비지 상태로 변화시킵니다. 해당 객체는 참조형 객체이므로 t2가 t1의 참조값으로 변경되어 t2는 t1의 값을 참조하게 됩니다. 그렇기에 t2를 생성할때 구조화된 메모리 공간이 가비지가 되는 것입니다.

- 하나의 인스턴스를 여러 개의 참조변수가 가리키는 것은 가능하나, 여러 개의 인스턴스를 하나의 참조변수가 가리키는 것은 불가능합니다.

## 생성자 메소드

클래스의 객체 생성(인스턴트화)시 호출되는 메소드입니다.

```
new 클래스명()
    ---------  생성자 메소드의 호출식
```

생성자 메소드는 객체의 멤버 변수들의 값을 초기화합니다.

클래스명과 동일한 메소드명을 가져야하며, 리턴타입을 반드시 생략해야 합니다.

메소드 오버로딩이 가능합니다. (오버로딩의 개수는 제한이 없습니다.)

클래스에는 생성자 메소드가 반드시 1개 이상 정의되어야 합니다.

생성자 메소드를 생략하면, 매개변수가 없는 생성자(default 생성자)가 자동 생성됩니다.

this, this(), super, super()를 이용하여 구현하는 것도 가능합니다.

```
class Student4{
	String name;
	int age;
	String subject;
//	멤버 변수들은 자동 초기화 됩니다. 문자열은 기본적으로 null입니다.
	
	Student4(){
//		System.out.println("호출"); 어떤 코드든 this함수 보다 순서가 위에 있으면 Constructor call must be the first statement in a constructor 에러가 발생합니다. (상속과 연관이 있습니다.)
		
		this("듀크", 28, "스프링");
//		아래의 생성자 메소드를 호출하는 것으로 같은 클래스 안에 있는 다른 생성자를 부르는 것입니다. 같은 기능을 두 번 구현해서 사용할 필요가 없기 때문입니다.
//		this메소드로 소괄호가 쳐져있는 경우 무조건 메소드입니다.
//		생성자 메소드 안에서만 사용이 가능하며 **반드시** 첫 행에 위치해야합니다. 

		System.out.println("호출 \n"); 
	}
	
	Student4(String name, int age, String subject) {
		this.name = name;
		this.age = age;
		this.subject = subject;
//		this 변수는 객체생성시 자동으로 생성되는 변수이며 변경이 불가능합니다.
	}
	
//	생성자 메소드
	void printStudentInfo() {
		System.out.printf("%s학생의 나이는 %d입니다. \n", name, age);
	}
	
	void study() {
		System.out.printf("%s학생은 %s과목을 학습합니다. \n", name, subject);
	}
	
	void setSubject(String subject) {
		this.subject = subject;
	}

}
```
